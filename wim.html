<script type='text/javascript'
        src='http://www.visualizing.org/sites/all/modules/custom/seedge_sprint/libs/d3/d3.v2.min.js'></script>
<!--<script type='text/javascript' src='../../D3/d3.v2.min.js'></script>-->

<style type="text/css">


body {
    font-family: Verdana, Arial, Helvetica, sans-serif;
    font-size: 10px;
    color: #bbb;
}

a {
    text-decoration: none;
}

a:active {
    color: #bbb;
}

a:visited {
    color: #090;
}

.feature {
    stroke: #555;
    stroke-width: .8px;
	stroke-opacity: 0;
	fill-opacity: 0;
}

/*
.axis line, .axis path {
}
*/

.main-axis path, .main-axis line, .main-axis text {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
/*	stroke: blue; */
}


line, .tikkies {
    fill: none;
    stroke: #000;
    stroke-width: .6px;
}


#middenas {
	visibility: hidden;
	z-index: 100;
}

#onderas {
	visibility: hidden;
	z-index: 100;
}

circle.node {
    stroke: black;
    stroke-width: .3px;
}


rect {
    fill: steelblue;
    stroke: grey;
}

.grid {
    fill: none;
    stroke: #000;
    stroke-width: .3px;
}

.astxt, .bartxt {
    font-size: 80%;
    fill: #999;
}

.stat {
    font-weight: bold;
    color: white;
}


#dekdiv {
	position: absolute;
	top: 0px;
	left: 0px;
	width: 100%;
	height: 110px;
	margin: 0px;
	padding: 0px;
	z-index: 6;
}	

#datapoints {
	z-index: 20;
	opacity: 1;
}
	
#header, #subheader, a:hover, #bijbakje, #expchooser, #buttonBar, #pielabelI, #pielabelII, #histolabel_x, #histolabel_y, .stat, .statlabel {
    text-shadow: .5px -.5px 1px #000;
}

#header {
	position: absolute;
	top: 500px;
	left: 336px;
	padding: 0px;
	margin: 0px;	
	font:  36px 'Arial Black', Impact;
	color: azure;
	z-index: 10;
}

#subheader {
	position: absolute;
	top: 25px;
	left: 500px;
	padding: 0px;
	margin: 0px;
	font:  italic 24px 'Times New Roman';
	color: #009DDC; /*colors used on http://water.chemistry2011.org/web/iyc: #B5F0FF; #009DDC */
	z-index: 11;
}

#map {
    position: absolute;
    background: #444;
    top: 0px;
    left: 0px;
}

#expchooser {
    position: absolute;
    top: 18px;
    left: 80px;
    z-index: 10;
    opacity: 0;
}

#experiments {
    height: 18px;
    padding: 0px;
    font-size: 9px;
	background-color: azure;
}


#bijbakje {
    position: absolute;
    top: 128px;
    left: 250px;
    width: 100px;
    text-align: right;
    opacity: 0;
}

/*
#schaalbakje {
    position: absolute;
    top: 25px;
    left: 106px;
    visibility: hidden;
}
*/

#buttonBar {
	position: absolute;
	left: 250px;
	top: 17px;
	height: 20px;
	width: auto;
	text-align: center;
	opacity: 0;
	z-index: 10;
}

#sortbylabel {
	position: absolute;
	top: -15px;
	left: 5px;
	font-weight: bold;
	color: lightblue;
}

#experiments, .sorters, div.tooltip {
	border: .5px solid indigo /*#383838*/ ; 
	border-radius: 4px;
   -moz-border-radius: 4px;
   -webkit-border-radius: 4px;
    box-shadow: 2px 2px 2px #777;
   -moz-box-shadow: 2px 2px 2px #777;
   -webkit-box-shadow: 2px 2px 2px #777;
}

.sorters {
	float: left;
	top: 0px;
	width: auto;
	height: 14px;
	padding-left: 3px;
	padding-right: 3px;
	margin-top: 0px;
	margin-bottom: 0px;
	margin-left: 3px;
	margin-right: 3px;
	background-image: -moz-linear-gradient(top, rgba(255,255,255,.25), rgba(255,255,255,.11));
	background-image: -webkit-gradient(linear,left top,left bottom,color-stop(0, rgba(255,255,255,.25)),color-stop(1, rgba(255,255,255,.11)));
	background-image: -webkit-linear-gradient(rgba(255,255,255,.25), rgba(255,255,255,.11));
	color: #fff;
	text-align: center;
}	
	
/* gradient button 
  font: 10px Helvetica Neue;
  background-color: #222;
  background-image: -moz-linear-gradient(top, rgba(255,255,255,.25), rgba(255,255,255,.11));
  background-image: -webkit-gradient(linear,left top,left bottom,color-stop(0, rgba(255,255,255,.25)),color-stop(1, rgba(255,255,255,.11)));
  background-image: -webkit-linear-gradient(rgba(255,255,255,.25), rgba(255,255,255,.11));
  color: #fff;
  text-rendering: optimizeLegibility;
  text-shadow: 0 -1px 1px #222;
  padding: 6px 10px 6px 10px;
  border: 0;
  border-radius: 0;
  border-bottom: 1px solid #222;
  margin: 0;
  -moz-box-shadow: 0 1px 3px #999;
  -webkit-box-shadow: 0 1px 3px #999;
*/


.sorters:hover {
	top: 2px;
	border: 1px solid black;
	background-color: lightgrey;
	color: black;
    box-shadow: 3px 4px 2px azure;
    -moz-box-shadow: 3px 4px 2px azure;
    -webkit-box-shadow: 3px 4px 2px azure;
}


#theNumbers {
    position: absolute;
    left: 4px;
    top: 52px;
    width: 220px;
    text-align: right;
    z-index: 10;
	opacity: 0;
}

#theNumbersBis {
    position: absolute;
    left: 242px;
    top: 52px;
    width: 220px;
    text-align: right;
    z-index: 10;
	opacity: 0;
}

#pieHole {
	position: absolute;
	top: 4px;
	left: 600px;
	width: 200px;
	text-align: center;
	z-index: 10;
    opacity: 0;
}

#pieI, #pieII {
	position: absolute;
	top: 30px;
}
	
#pieI {
	left: 10px;
}
	
#pieII {
	left: 84px;
}

#pielabelI, #pielabelII {
	position: absolute;
	top: 12px;
	width: 70px;
}
	
#pielabelII {
	left: 75px;
}

#histo {
    position: absolute;
    left: 4px;
    top: 362px;
}

#histolabel_x, #histolabel_y {
    position: absolute;
    opacity: 0;
}

#histolabel_y {
    top: 16px;
    left: 20px;
}

#histolabel_x {
    top: 162px;
    left: 170px;
}

#source {
    position: absolute;
    bottom: 6px;
    left: 390px;
    color: #999;
}

div.tooltip {
    position: absolute;
    width: 200px;
    height: auto;
    padding: 6px 2px 6px 2px;
    text-shadow: .5px .5px 1px dimgrey;
    /*    font: 24px sans-serif; */
    background: red;
    color: black;
    border: solid 1px dimgrey;
    border-radius: 4px;
    -webkit-border-radius: 4px;
    -mozilla-border-radius: 4px;
    text-align: center;
    z-index: -10;
    opacity: 0;
}


</style>


<div id="map">
    <div id="source">source: <a href="http://water.chemistry2011.org/web/iyc" target="_blank">The Global Experiment of
        the International Year of Chemistry</a></div>
</div>


<div id="header">World Wide Water Quality
    <div id="subheader">2011</div>
</div>

<div id="dekdiv">

 <div id="expchooser">
        <label for="experiments">experiment #</label>
        <select id="experiments">
            <option value="ph_data">1: pH</option>
            <option value="sa_data">2: salinity</option>
            <option value="di_data">3: dirt</option>
        </select>
</div>


<div id="bijbakje"></div>
<!-- <div id="schaalbakje"></div>-->



<div id="buttonBar">
	<div id="sortbylabel">sort by: </div>	
	
	<div id="sorter" class="sorters">...</div>
	<div id="tymover" class="sorters">type</div>
	<div id="scmover" class="sorters">source</div>
	<div id="tmover"  class="sorters">&degC</div>
	<div id="cmover"  class="sorters">country</div>
	<div id="tomap"   class="sorters">map</div>
<!--	<div id="mover"   class="sorters">raw</div>
	<div id="nmover"  class="sorters"># stud.</div>
-->

</div>

<div id="theNumbers"></div>
<div id="theNumbersBis"></div>

<div id="pieHole"> 
   <div id="pieI"></div>
   <div id="pielabelI">water type</div>
   <div id="pieII"></div>
   <div id="pielabelII">water source</div>
</div>

</div>

<div id="histo">
    <div id="histolabel_x">result</div>
    <div id="histolabel_y">frequency</div>
</div>


<script>


/**
 *Variables and settings
 **/

var activeDataset;

//needed for radius consistency during zooms and for updates
var reeks, globalData, globalfirstVar, globalsecondVar, globalfirstVarlabel, globalsecondVarlabel;

var currentWatertype = "",
	currentWatersource = ""; 

var measurementCircles, detailsCircles, highlightTimer, selectedPath = null;
// timer to keep interaction responsive while highlighting measurement dots

var margin = {top:0, right:0, bottom:0, left:0},
    width = 1048 - margin.left - margin.right,
    height = 560 - margin.top - margin.bottom;


var projection = d3.geo.mercator()
					   .scale(width)
					   .translate([width / 2.3, height / 1.6]);


var path = d3.geo.path()
			 .projection(projection);

var q = projection.scale();

var zoom = d3.behavior.zoom()
			 .translate(projection.translate())
			 .scale(projection.scale())
			 .scaleExtent([height, 64 * height])
			 .on("zoom", move);


//prelimenary scaling stuff
var lowColor,
    midColor,
    highColor;

var r = d3.scale.linear();
var c = d3.scale.linear();
var yAs = d3.scale.linear();
var xAs = d3.scale.linear();


d3.select("#experiments").property("value", "ph_data");


/**
 *Draw map
 **/
var svg = d3.select("#map")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
            .call(zoom);


var g = svg.append("g"),
    feature = g.selectAll(".feature") 


svg.append("g").attr("id", "datapoints");



var timings = { 					    	featureIn:	     250,
				rondjesInOutdelay:     250, rondjesInOut:   1000,

										    gradientInOut:   100,
				
				
											histoOut:        100,
				histoBarsIndelay: 	  1250, histoBarsIn:     250,
				histoAssenIndelay: 	  1500, histoAssenIn: 	 250,
				histoBarsTextIndelay: 2000, histoBarsTextIn: 250,
				histoLabelsIndelay:   2250, histoLabelsIn:   250,
				
											pieOut:			 100, //not used
				
				controlsInDelay: 	  2500, controlsIn:      250,
				
											featureInOut:    1000,
				
			//	duckdivIn:			   500,
				
				yAsInOutDelay:		   500, yAsInOut:        250,
				
											barsliceInOut:   250,
				
											tooltipInOut:    250,
				
											overpathInOut:   250,
				
				ripplerDelay1: 		   250, 
				ripplerDelay2: 		   500,
				ripplerDelay3: 		   750,
				ripplerDelay: 		  1000, rippler: 		  50
			   };	

   
/**
 * setup color key holder and gradient
 **/
/* 
var w = 100,
    h = 6;

var bakje = d3.select("#schaalbakje")
			  .append("svg")
			  .attr("width", w)
			  .attr("height", h)
			  .append("svg:g");

			  
			  
var gradient = bakje.append("svg:defs")
					.append("svg:linearGradient")
					.attr("id", "gradient")
					.attr("x1", "0%")
					.attr("y1", "0%")
					.attr("x2", "100%")
					.attr("y2", "0%")
					.attr("spreadMethod", "pad");

*/
		
//pie scales and sizes
var wpie = 50,
    hpie = 50,
    rpie = Math.min(wpie, hpie) / 2,
    typecolor = d3.scale.ordinal()
						.range(["deepskyblue", "aquamarine", "lightgrey"]),
    sourcecolor = d3.scale.ordinal()
						  .range(["#7B86EF", "#6371ED", "#4E5EEA", "#283BE6", "#1A2DDA", "#1729C5", "#13219F", "#0D176D", "lightgrey"]);
		
		

/**
 * setup histogram
 **/

var histw = 160,
    histh = 120,
    histpad = 60;

var his = d3.select("#histo")
			.append("svg")
			.attr("width", histw + histpad)
			.attr("height", histh + histpad)
			.append("svg:g")
			.attr("transform", "translate(40,40)");


/**
 *
 */

var lastData = null;
var maxt = 1,
    mint = 0,
    mt = 0;


function isExists(obj) { return typeof(obj) != 'undefined' && obj != null };


var replaceCountry = {
  "Russian Federation":"Russia", "Tuninsia":"Tunisia", "United State of America":"United States of America", "United States":"United States of America", "USA":"United States of America", "US":"United States of America", /*"Georgia":"United States of America" // ???!!!,*/ "Hong Kong":"China", "UK":"United Kingdom", "uk":"United Kingdom", "España":"Spain", "SLOVAKIA":"Slovakia", "Slovákia":"Slovakia", "Slovensko":"Slovakia", "Türkiye":"Turkey", "turkey":"Turkey", "Serbia":"Republic of Serbia", "Bosna i Hercegovina":"Bosnia and Herzegovina", "Scotland":"United Kingdom"
}

/** Correct names of countries

 Afghanistan, Angola, Albania, United Arab Emirates, Argentina,
 Armenia, Antarctica, French Southern and Antarctic Lands,
 Australia, Austria, Azerbaijan, Burundi, Belgium, Benin,
 Burkina Faso, Bangladesh, Bulgaria, The Bahamas, Bosnia and Herzegovina
 Belarus, Belize, Bolivia, Brazil, Brunei, Bhutan, Botswana,
 Central African Republic, Canada, Switzerland, Chile, China,
 Ivory Coast, Cameroon, Democratic Republic of the Congo, Republic of the Congo, Colombia,
 Costa Rica, Cuba, Northern Cyprus, Cyprus, Czech Republic, Germany, Djibouti, Denmark, Dominican Republic
 Algeria, Ecuador, Egypt, Eritrea, Spain, Estonia, Ethiopia, Finland, Fiji, Falkland Islands, France, Gabon
 United Kingdom, Georgia, Ghana, Guinea, Gambia, Guinea Bissau, Equatorial Guinea, Greece, Greenland, Guatemala
 Guyana, Honduras, Croatia, Haiti, Hungary, Indonesia, India, Ireland, Iran, Iraq, Iceland, Israel, Italy
 Jamaica, Jordan, Japan, Kazakhstan, Kenya, Kyrgyzstan, Cambodia, South Korea, Kosovo, Kuwait, Laos, Lebanon
 Liberia, Libya, Sri Lanka, Lesotho, Lithuania, Luxembourg, Latvia, Morocco, Moldova, Madagascar, Mexico,
 Macedonia, Mali, Myanmar, Montenegro, Mongolia, Mozambique, Mauritania, Malawi, Malaysia, Namibia,
 New Caledonia, Niger, Nigeria, Nicaragua, Netherlands, Norway, Nepal, New Zealand, Oman,
 Pakistan, Panama, Peru, Philippines, Papua New Guinea, Poland, Puerto Rico, North Korea,
 Portugal, Paraguay, Qatar, Romania, Russia, Rwanda, Western Sahara, Saudi Arabia, Sudan
 South Sudan, Senegal, Solomon Islands, Sierra Leone, El Salvador, Somaliland, Somalia
 Republic of Serbia, Suriname, Slovakia, Slovenia, Sweden, Swaziland, Syria, Chad,
 Togo, Thailand, Tajikistan, Turkmenistan, East Timor, Trinidad and Tobago,
 Tunisia, Turkey, Taiwan, United Republic of Tanzania, Uganda, Ukraine, Uruguay,
 United States of America, Uzbekistan, Venezuela, Vietnam, Vanuatu, West Bank,
 Yemen, South Africa, Zambia, Zimbabwe

 **/
    
    /* If only the UNESCO had used the official UN abreviations... ;) */   

function initMap(data) {
    lastData = {};
    for (var i = 0; i < data.length; i++) {
        var d = data[i];
        var ccn = replaceCountry[d.country] || d.country;

        if (!isExists(lastData[ccn]))
            lastData[ccn] = [];

		if (globalfirstVar == "ph" && d[globalfirstVar] < 5) continue;
		
		if (globalfirstVar == "sanity" && d[globalfirstVar] >= 24) continue;

        if (globalfirstVar == "dropsofbleach" && d[globalfirstVar] >= 799) continue;

        lastData[ccn].push(d);
    }
}


/**
*Draw map
**/
  //d3.json("world-countries.json", function(collection) {
d3.json("/sites/default/files/sprint/data/world-countries.json", function (collection) {

    feature = feature
					 .data(collection.features)
					 .enter().append("path")
					 .attr("class", "feature")
					 .attr("d", path)
					 .attr('fill', '#222')
					 .on("mouseover", overpath)
					 .on("mousemove", moverpath)
					 .on("click", clickPath)
					 .on("mouseout", outpath)
					 
					 .transition()
					 .duration(timings.featureIn)
					 .style("fill-opacity", 1)
					 .style("stroke-opacity", 1);
			 
    updateDataset();
	
});


function updateDataset() {


d3.selectAll("#middenas, #onderas, #bijbakje")	   
		.transition()
		.duration(timings.yAsInOut)
		.style("visibility", "hidden")
		.style("z-index", -10);
		
		
d3.selectAll(".feature")
			.transition()
			.duration(timings.featureInOut)
			.style("fill-opacity", 1)
			.style("stroke-opacity", 1);
		
/*				
d3.selectAll("#duckdiv")	   
		.transition()
		.duration(timings.yAsInOut)
		.style("top", "0px")
		.style("left", "0px")
		.style("width", "100%")
		.style("height", "560px")
		.style("opacity", 1e-6)
		.style("z-index", -10);
		
*/
    var picker = d3.select("#experiments").property("value");

    if (activeDataset == picker) return;

    else

        activeDataset = picker;

    if (picker == "ph_data") {
        swap_to_Exp("red", "green", "blue", "pH", "ph", "temperature (in \u00b0C)", "temperature");
    }
	
    else

    if (picker == "sa_data") {
        swap_to_Exp("green", "greenyellow", "white", "salinity", "sanity", "salinity by weight", "sanitybyweight");
    }

    else

    if (picker == "di_data") {
        swap_to_Exp("green", "orange", "red", "drops of bleach", "dropsofbleach", "temperature (in \u00b0C)", "temperature");
    }
	
    //	else
    //	if (picker == "gwe_experiment4_v1") { swap_to_Exp(); }

//the still efficiency dataset only has one variable that has to be plotted - how can this be made to fit the experiment changer routine?

//actually the still experiment is somewhat different from the other three, which are all related to water quality
//the still experiment should have a graph of its own!!!
	
	
//another actually: actually the three 'experiments' are not experiments at all, they are measurements

};


function swap_to_Exp(lowColor, midColor, highColor, firstVarlabel, firstVar, secondVarlabel, secondVar) {


	

/**
* Load data from JSONs and draw visualization
**/
 
  //d3.json("gwe_experiment1_v1.json", function(ph_data) {
	
  //d3.json("gwe_experiment2_v1.json", function(sa_data) {
	
  //d3.json("gwe_experiment3_v1.json", function(di_data) {
	
d3.json("/sites/default/files/sprint/data/gwe_experiment1_v1.json", function(ph_data) {
	
d3.json("/sites/default/files/sprint/data/gwe_experiment2_v1.json", function(sa_data) {
	
d3.json("/sites/default/files/sprint/data/gwe_experiment3_v1.json", function(di_data) {


	
	
//////////////////////////////////////////////////////////	
///please note the data filters to take out outliers!!!/// 	
//////////////////////////////////////////////////////////


//filter out one unlikely outlier	
         if (firstVar == "ph") { data = ph_data.filter(function (d) { return d[firstVar] >= 5; }); }

//reason to take out this measurement:

	//{"city":"Nanticoke","coordinates":[-75.903898,38.274504],"country":"United States","natureofthewater":"fresh","numberofstudents":17,"ph":3.68,"school":"Luzerne County Community College","sourceofwater":"Lackawanna River","teacher":"Lewis","temperature":20,"waterType":"fresh","waterSource":"stream, river, canal"}
	
//this one measurement has a weirdly low value for ph, it is a rather extreme outlier - it is out of the dataset for now (filtered).
//is it legit to take it out? someone should ask the school about this.
		 
		 
//filter out two specific data entry errors / this is done by filtering on salinity by weight, this is the 'secondVar'!
        if (firstVar == "sanity") { data = sa_data.filter(function (d) { return d[secondVar] < 24; }); }
		
//resason to take out these two measurements:
    //{"city":"Milano","coordinates":[9.18103,45.468945],"country":"Italy","natureofthewater":"fresh","numberofstudents":19,"sanity":0.24,"sanitybyweight":24,"school":"Facoltà di Agraria-Università degli studi di Milano","sourceofwater":"Casalmaiocco (LO), tapwater","teacher":"Gigliola","waterType":"fresh","waterSource":"tap"},
    //{"city":"Milano","coordinates":[9.18103,45.468945],"country":"Italy","natureofthewater":"fresh","numberofstudents":19,"salinity":0.62,"salinitybyweight":62,"school":"Facoltà di Agraria-Università degli Studi di Milano","sourceofwater":"Milano, tap water","teacher":"Leonardo","waterType":"fresh","waterSource":"tap"}

//this school seems to have accidentally swapped salinity and salinity by weight - I changed it around, but this has to be checked though!!!

		
//another note: this dataset still speaks of sanity instead of salinity - this should be corrected!

		
		
//filter out one highly unlikely outlier
        if (firstVar == "dropsofbleach") { data = di_data.filter(function (d) { return d[firstVar] < 799; }); }

//reason to take out this measurement:

//{"city":"Tumon","coordinates":[144.799072,13.50454],"country":"United States","dropsofbleach":799,"natureofthewater":"Fresh","numberofstudents":7,"school":"St. Johns School of Guam","sourceofwater":"Tap","teacher":"Hieter","temperature":26,"waterType":"fresh","waterSource":"tap"},	

//they mention 799 drops of bleach?! This seems unrealistically high. Probably some error.

		 
//note: it is also possible to leave in the outliers, and have the user filter them out interactively
//better not probably



    globalfirstVar = firstVar;
    globalsecondVar = secondVar;
    globalfirstVarlabel = firstVarlabel;
    globalsecondVarlabel = secondVarlabel;
    globalData = data;
	
	data.forEach(function(d) { return d.backoordinates = d.coordinates; });

    initMap(data);


    gemfirstVar = d3.round(d3.mean(data, function (d) { return d[firstVar]; }), 2);
    gemsecondVar = d3.round(d3.mean(data, function (d) { return d[secondVar]; }), 2);

    reeks = data.map(function (d) { return d[firstVar]; });

    // scale for temperature to radius
    r.domain(d3.extent(data.map(function (d) { return d[secondVar]; })))
     .range([1 * (q / width), 6 * (q / width)]);


    // scale for ph to color
    c.domain([d3.min(data, function (d) { return d[firstVar]; }), gemfirstVar, d3.max(data, function (d) { return d[firstVar];
    })])
    .range([lowColor, midColor, highColor]);
	

	xAs.domain([0, data.length-1]).range([0, 650]);
	
	yAs.domain([d3.min(data, function (d) { return d[firstVar]; }), d3.max(data, function (d) { return d[firstVar];
    })]).range([355,0]);
		 
// refill circles


d3.select("#sorter").html(firstVarlabel);
	

    rondjes = svg.select("#datapoints").selectAll("circle")
									   .data(data, function(d) { return d.coordinates; })
									
	rondjes.enter().append("circle")
		.attr('class', 'measurementCircle')
		.style("fill", function (d) { return c(d[firstVar]); })
		.style("stroke", function (d) { return d3.rgb(c(d[firstVar])).darker(); })
	 	.attr("r", 0)
	//	.style("fill", "#aaa")
		.attr("transform", function (d) { return "translate(" + projection(d.coordinates) + ")"; })
        .on("mouseover", tooltipper)
        .on("mousemove", toolmover)
        .on("mouseout", tooltapper)
		.on("click", ripple)
	//	.attr("visibility", "visible")

		.transition()
		.delay(timings.rondjesIndelay)
		.duration(timings.rondjesInOut)
		.attr("r", function (d) { return r(d[secondVar]); });
/*	
		.style("fill", function (d) { return c(d[firstVar]); })
		.style("stroke", function (d) { return d3.rgb(c(d[firstVar])).darker(); })
		

	rondjes.append("text")
    //    .attr("y", function (d) { return deth - y(d); })
        .style("fill", "#444")
        .style("font-size", "8px")
        .text(function (d) { return d.school; })
		.attr("transform", "translate("+ 5 + "," + 300 + ")rotate(-90)");
*/		
				
	rondjes.transition()
		   .delay(timings.rondjesInOutdelay)
		   .duration(timings.rondjesInOut)
		   .style("fill", function (d) { return c(d[firstVar]); })
		   .style("stroke", function (d) { return d3.rgb(c(d[firstVar])).darker(); })
		   .attr("r", function (d) { return r(d[secondVar]); })
		   .attr("transform", function (d) { return "translate(" + projection(d.coordinates) + ")"; });

	   
	rondjes.exit()
		   .transition()
		   .delay(timings.rondjesInOutdelay)
		   .duration(timings.rondjesInOut)
		   .attr("r", 0)
		   .style("fill", "#aaa")
		   .remove();

//	console.log(rondjes);	   
						  		 
		 
				
//gather data for pies 
// this can also be done with d3.nest to extract the variables and their lenghts, but that messes up the order of the watertypes and sources

types = [];
sources = [];

types.push({ "type": "fresh", "size": data.filter(function(d) { return d.waterType == "fresh"; }).length });
types.push({ "type": "salt", "size": data.filter(function(d) { return d.waterType == "salt"; }).length });
types.push({ "type": "unknown", "size": data.filter(function(d) { return d.waterType == "unknown"; }).length });

sources.push({ "source": "tap", "size": data.filter(function(d) { return d.waterSource == "tap"; }).length });
sources.push({ "source": "drinking supply", "size": data.filter(function(d) { return d.waterSource == "drinking supply"; }).length });
sources.push({ "source": "ground", "size": data.filter(function(d) { return d.waterSource == "ground"; }).length });
sources.push({ "source": "rain", "size": data.filter(function(d) { return d.waterSource == "rain"; }).length });
sources.push({ "source": "stream, river, canal", "size": data.filter(function(d) { return d.waterSource == "stream, river, canal"; }).length });
sources.push({ "source": "pond, lake, pool", "size": data.filter(function(d) { return d.waterSource == "pond, lake, pool"; }).length });
sources.push({ "source": "ocean", "size": data.filter(function(d) { return d.waterSource == "ocean"; }).length });
sources.push({ "source": "waste water", "size": data.filter(function(d) { return d.waterSource == "waste water"; }).length });
sources.push({ "source": "unknown", "size": data.filter(function(d) { return d.waterSource == "unknown"; }).length });


donut = d3.layout.pie()
		  .sort(null)
		  .value(function(d) { return d.size; });	

arc = d3.svg.arc().outerRadius(rpie);
 
				
				
doHistogram();



var xAxis = d3.svg.axis()
			.scale(xAs)
			.orient("bottom")
			  .ticks(8)
			  .tickSize(6, 3);
				 
var yAxis = d3.svg.axis()
			  .scale(yAs)
			  .orient("left")
			  .ticks(8)
			  .tickSize(6, 3);
				 
		
	hetxAsje = svg.append("g")
				 .attr("id", "onderas")
				 .attr("class", "main-axis")
				 .attr("transform", "translate(238,480)")
				 .call(xAxis);

	hetyAsje = svg.append("g")
				 .attr("id", "middenas")
				 .attr("class", "main-axis")
				 .attr("transform", "translate(238,123)")
				 .call(yAxis);
				 
/**
*Gradient legend for pH values / needs tickmarks
**/
 /*
	gradient.selectAll("stop")
		    .transition()
		    .duration(timings.gradientInOut)
		    .style("opacity", 1e-6)
		    .remove();


    gradient.append("svg:stop")
            .attr("offset", "0%")
            .attr("stop-color", lowColor)
			
		    .transition()
		    .duration(timings.gradientInOut)
            .attr("stop-opacity", 1);

    gradient.append("svg:stop")
            .attr("offset", "50%")
            .attr("stop-color", midColor)
			
		    .transition()
		    .duration(timings.gradientInOut)
            .attr("stop-opacity", 1);

    gradient.append("svg:stop")
            .attr("offset", "100%")
            .attr("stop-color", highColor)
		 
		    .transition()
		    .duration(timings.gradientInOut)
            .attr("stop-opacity", 1);

			
    bakje.append("rect")
         .attr("width", w)
         .attr("height", h)
         .attr("rx", "4px")
         .attr("ry", "4px")
         .style("fill", "url(#gradient)");
*/
    d3.select("#bijbakje")
	  .text(firstVarlabel);
	  
	nrOstud = d3.sum(data, function(d) { return d.numberofstudents; });

        //this is a lot of html within the code
        d3.select("#theNumbers")
          .html("<span class=\"statlabel\">number of measurements: </span><span class=\"stat\">" + reeks.length + "</span><br/><br/><span class=\"statlabel\">average " + firstVarlabel + ": </span><span class=\"stat\">" + gemfirstVar + "</span><br/><span class=\"statlabel\">average " + secondVarlabel + ": </span><span class=\"stat\">" + gemsecondVar + "</span>");

        d3.select("#theNumbersBis")
          .html("<span class=\"statlabel\">number of students involved: </span><span class=\"stat\">" + nrOstud + "</span>");

	  
	  
  
/* 	attempts at adding an explanatory axis to the gradient
         bakas = d3.svg.axis()
         .scale(c)
         .ticks(4)
         .orient("bottom");


       bakje.append("g")
         .attr("class", "x axis")
         .attr("transform", "translate(," + 4 + ")")
         //      .attr("x1", 0)
         //     .attr("x2", 100)
         .call(bakas);
*/		 	


    d3.selectAll("#expchooser, #buttonBar, #theNumbers, #theNumbersBis, #pieHole") //#bijbakje, 
      .transition()
      .delay(timings.controlsInDelay)
      .duration(timings.controlsIn)
      .style("opacity", .88);
/*		
    d3.selectAll("#schaalbakje")
      .transition()
      .delay(timings.controlsInDelay)
      .duration(timings.controlsIn)
      .style("opacity", 1);
*/		

		
//the pies could me made a lot slicker by using proper updates (with tweens) instead of remove/appends
//a try at making the pies replace the drop downs for waterType and waterSource
//m aybe they should be made to stick to a selection after a click on a slice
			
	d3.selectAll("#pieI, #pieII").select("svg")
								// .transition()
								// .duration(timings.pieOut)
								// .style("opacity", 1e-6)
								 .remove();
					
			
var visI = d3.select("#pieI")
			 .append("svg")
			 .data([types])
			 .attr("width", wpie)
			 .attr("height", hpie);

var arcsI = visI.selectAll("g.arc")
				.data(donut)
				.enter().append("svg:g")
				.attr("class", "arc")
				.attr('id', function (d, i) { return 'pieSliceI-' + i; })
				.attr("transform", "translate(" + rpie + "," + rpie + ")")
                .on('mouseover', markpieSliceI)
                .on('mouseout', unmarkpieSliceI);

			
	arcsI.append("path")
		 .style("fill", function(d, i) { return typecolor(i); })
		 .style("stroke", function(d, i) { return d3.rgb(typecolor(i)).darker(); })
		 .attr("d", arc);
	
	arcsI.append("title")
		 .text(function(d) { return d.data.type + ": " + d.data.size; })	


	
	
var visII = d3.select("#pieII")
			  .append("svg")
			  .data([sources])
			  .attr("width", wpie)
			  .attr("height", hpie);

var arcsII = visII.selectAll("g.arc")
				  .data(donut)
				  .enter().append("svg:g")
				  .attr("class", "arc")
				  .attr('id', function (d, i) { return 'pieSliceII-' + i; })
				  .attr("transform", "translate(" + rpie + "," + rpie + ")")
                  .on('mouseover', markpieSliceII)
                  .on('mouseout', unmarkpieSliceII);
				
	arcsII.append("path")
		  .style("fill", function(d, i) { return sourcecolor(i); })
		  .style("stroke", function(d, i) { return d3.rgb(sourcecolor(i)).darker(); })
		  .attr("d", arc);
	
	arcsII.append("title")
		  .text(function(d) { return d.data.source + ": " + d.data.size; });	
		  
		  
//this can be made much shorter:		  
		
function markpieSliceI(d, i) {

currentWatertype = d.data.type;
//console.log(currentWatertype);

    // make all slices, except the hovered slice, semi transparent
    var selectedPieId = 'pieSliceI-' + i;

    visI.selectAll('.arc')
	   .transition()
       .duration(timings.barsliceInOut)
       .style('opacity', function (d, i) { return ( d3.select(this).attr('id') != selectedPieId ) ? 0.6 : 1; });

	updateVisibility()
};



function markpieSliceII(d, i) {

currentWatersource = d.data.source;

    // make all slices, except the hovered slice, semi transparent
    var selectedPieId = 'pieSliceII-' + i;

    visII.selectAll('.arc')
	   .transition()
       .duration(timings.barsliceInOut)
       .style('opacity', function (d, i) { return ( d3.select(this).attr('id') != selectedPieId ) ? 0.6 : 1; });

	updateVisibility()
};


function unmarkpieSliceI(d, i) {

	currentWatertype = "";
	
    // remove transparency from all slices
    visI.selectAll('.arc')
	   .transition()
       .duration(timings.barsliceInOut)
	   .style("opacity", 1);

	updateVisibility();

}

function unmarkpieSliceII(d, i) {

	currentWatersource = "";
	
    // remove transparency from all slices
    visII.selectAll('.arc')
	   .transition()
       .duration(timings.barsliceInOut)
	   .style("opacity", 1);

	updateVisibility();

};

        tooltipdiv = d3.select("body")
					   .append("div")
					   .attr("class", "tooltip");


        //This is quite a lot of html code inside the d3 code - isn't there a better way to do this?

        function tooltipper(d) {
            tooltipdiv
                //	.style("height", "40px")
                    .html("<span class=\"statlabel\">" + firstVarlabel + ": </span><span class=\"stat\">" + d[firstVar] + "</span><br/><span class=\"statlabel\">" + secondVarlabel + ": </span><span class=\"stat\">" + d[secondVar] + "</span><br/><span class=\"stat\">" + d.waterType + "</span><span class=\"statlabel\"> water</span><br/><span class=\"statlabel\">source: </span><span class=\"stat\">" + d.waterSource + "</span><br/><br/><span class=\"schoollabel\">(" + d.school + ", " + d.country + ")</span><br/><span class=\"schoollabel\"># of students: " + d.numberofstudents + "</span>")
                    .style("background", c(d[firstVar]))
					.style("width", "200px")
                    .style("z-index", 1000)

                    .transition()
                    .duration(timings.tooltipInOut)
                    .style("opacity", 1);
        };

        function toolmover() {
            tooltipdiv
                    .style("top", d3.event.pageY > height / 2 ? (d3.event.pageY - 102) + "px" : (d3.event.pageY + 12) + "px")
                    .style("left", d3.event.pageX > width / 2 ? (d3.event.pageX - 212) + "px" : (d3.event.pageX + 12) + "px");
        };

        function tooltapper() {
            tooltipdiv
                    .transition()
                    .duration(timings.tooltipInOut)
                    .style("opacity", 1e-6)
                    .style("z-index", -10);
			};
	
        });
     });
  });
};


function doHistogram(reeks) {

//histogramcode

    if (!isExists(reeks))
        reeks = window.reeks;

    d3.selectAll(".grid, .tikkies, .hisrect, text")
      .transition()
      .duration(timings.histoOut)
      .style("opacity", 1e-6)
      .remove(); //.transition().duration(1000)


    var histogram = d3.layout.histogram()(reeks);

    var x = d3.scale.ordinal()
              .domain(histogram.map(function (d) { return d.x; }))
              .rangeBands([0, histw]);

    var y = d3.scale.linear()
              .domain([0, d3.max(histogram, function (d) { return d.y; })])
              .range([0, histh]);


d3.selectAll("#histolabel_y, #histolabel_x")
  .transition()
  .delay(timings.histoLabelsIndelay)
  .duration(timings.histoLabelsIn)
  .style("opacity", 1);

    var rules = his.selectAll("g.rule")
				   .data(y.ticks(10))
				   .enter()
				   .append("svg:g")
				   .style("opacity", 1e-6)
				   .attr("transform", function (d) { return "translate(0," + (histh - y(d)) + ")"; });


    rules.append("line")
         .attr("class", "tikkies")
         .attr("x1", -1)
         .attr("x2", -5);


    rules.append("line")
         .attr("class", "grid")
         .attr("x1", 1)
         .attr("x2", histw);


    rules.append("text")
         .attr("class", "astxt")
         .attr("x", -15)
         .attr("dy", ".71em")
         .attr("text-anchor", "middle")
         .text(y.tickFormat(10))
         .style("display", function (d) { return d == 0 ? "none" : null });

		 
    rules.transition()
         .delay(timings.histoAssenIndelay)
         .duration(timings.histoAssenIn)
         .style("opacity", 1);


	his.append("line")
	   .attr("x1", 0)
	   .attr("x2", histw)
       .attr("y1", histh)
       .attr("y2", histh)
       .style("opacity", 1e-6)

       .transition()
       .delay(timings.histoAssenIndelay)
       .duration(timings.histoAssenIn)
       .style("opacity", 1);
	   

	his.append("line")
       .attr("x1", 0)
       .attr("x2", 0)
       .attr("y1", 0)
       .attr("y2", histh)
       .style("opacity", 1e-6)

	   .transition()
       .delay(timings.histoAssenIndelay)
       .duration(timings.histoAssenIn)
       .style("opacity", 1);

		 
    var bars = his.selectAll("g.bars")
                  .data(histogram)
                  .enter().append("svg:g")
                  .attr('class', 'histoBar')
                  .attr('id', function (d, i) { return 'histoBar-' + i; })
                  .attr("transform", function (d) { return "translate(" + x(d.x) + "," + (histh - y(d.y)) + ")"; })
                  .on('mouseover', markHistogramBar)
                  .on('mouseout', unmarkHistogramBar);


    bars.append("rect")
        .attr("class", "hisrect")
        .attr("width", x.rangeBand())
        .attr("y", function (d) { return y(d.y); })
        .attr("height", 0)
        .style("fill", function (d) { return c(d.x); })
        .style("stroke", function (d) { return d3.rgb(c(d.x)).darker(); })

        .transition()
        .delay(2450)
        .duration(750)
        .attr("y", 0)
        .attr("height", function (d) { return y(d.y); });

		
    bars.append("text")
        .attr("class", "bartxt")
        .attr("x", x.rangeBand() / 2)
        .attr("y", 0)
        .attr("dy", "-.35em")
        .attr("text-anchor", "middle")
        .text(function (d) { return d3.round(d.x, 1) })
        .style("opacity", 1e-6)

        .transition()
        .delay(3250)
        .duration(750)
        .style("opacity", 1);

}


function markHistogramBar(d, i) {

    // make all bars, except the hovered bar, semi transparent
    var selectedBarId = 'histoBar-' + i;

    his.selectAll('.histoBar')
	   .transition()
       .duration(timings.barsliceInOut)
       .style('opacity', function (d, i) { return ( d3.select(this).attr('id') != selectedBarId ) ? 0.3 : 1; });

    highlightMeasurements(globalfirstVar, d.x, d.x + d.dx);

}

function unmarkHistogramBar(d, i) {

    // remove transparency from all bars
    his.selectAll('.histoBar')
	   .transition()
       .duration(timings.barsliceInOut)
	   .style('opacity', 1);

    highlightMeasurements(null);

}


function highlightMeasurements(metric, lowerBound, upperBound) {

    if (highlightTimer != null) {
        clearTimeout(highlightTimer);
    }
//should be replaced by an interaction with the pies
    var watertype = currentWatertype;
    var watersource = currentWatersource;

    highlightTimer = setTimeout(function () {
        var needObj = rondjes;
        if (isExists(detailsCircles))
            needObj = detailsCircles;
        needObj.style('visibility', function (d, i) {


            if (( ( metric == null ) || ( d[ metric ] >= lowerBound && d[ metric ] <= upperBound ) ) &&
                    (watertype == "" || watertype == d.waterType) && (watersource == "" || watersource == d.waterSource)) {
                return 'visible';
            }
            else {
                return 'hidden';
            }
        });

    }, 350);

}


/**
 * Update visibility settings based on selections
 * Please note: this is the code that used to respond to the dropdowns, I have reworked it to respond to mouseovers on the pioeslices
 **/

 
function updateVisibility() {

// kill pending visibility change set by function highlightMeasurements()
    if (highlightTimer != null) {
        clearTimeout(highlightTimer);
    }
	
	  rondjes.attr("visibility", function (d) {
                return (currentWatertype == "" || currentWatertype == d.waterType) && (currentWatersource == "" || currentWatersource == d.waterSource) ? "visible" : "hidden";
            });


// This bit updates the field containing the averages and other stats  
    filteredData = globalData.filter(function (d) {
        return (currentWatertype == "" || d.waterType == currentWatertype) && currentWatersource == "" || d.waterSource == currentWatersource;
    })


    gemfirstVar = d3.round(d3.mean(filteredData, function (d) { return d[globalfirstVar]; }), 2);
    gemsecondVar = d3.round(d3.mean(filteredData, function (d) { return d[globalsecondVar]; }), 2);


//for histogram & stats
    reeks = filteredData.map(function (d) { return d[globalfirstVar]; });

	
    doHistogram();

	
	nrOstud = d3.sum(filteredData, function(d) { return d.numberofstudents; });
	
//for reporting correct averages
    if (reeks.length == 0) {
        gemfirstVar = 0;
        gemsecondVar = 0;
    };

        d3.select("#theNumbers")
          .html("<span class=\"statlabel\">number of measurements: </span><span class=\"stat\">" + reeks.length + "</span><br/><br/><span class=\"statlabel\">average " + globalfirstVarlabel + ": </span><span class=\"stat\">" + gemfirstVar + "</span><br/><span class=\"statlabel\">average " + globalsecondVarlabel + ": </span><span class=\"stat\">" + gemsecondVar + "</span>");

        d3.select("#theNumbersBis")
          .html("<span class=\"statlabel\">number of students involved: </span><span class=\"stat\">" + nrOstud + "</span>");


};



///
//circlemoving routines
///
//these should be d3-ified by using scales!!!
///

function Sortum() {

if (globalfirstVar == "ph") {
	data = data.sort(function(d,e) { return d3.ascending(d.ph, e.ph); });	   
}
else
if (globalfirstVar == "sanity") {
	data = data.sort(function(d,e) { return d3.ascending(d.sanity, e.sanity); });	   
}
else
if (globalfirstVar == "dropsofbleach") {
	data = data.sort(function(d,e) { return d3.ascending(d.dropsofbleach, e.dropsofbleach); });	   
}

circularUpdater();
  
};
	   



function TyMovum() {

data = data.sort(function(d,e) { return d3.ascending(d.waterType, e.waterType); });	 
  
circularUpdater();

};	


function ScMovum() {

data = data.sort(function(d,e) { return d3.ascending(d.waterSource, e.waterSource); });	   

circularUpdater();

};	


function TMovum() {

if (globalfirstVar == "sanity") {
	data = data.sort(function(d,e) { return d3.ascending(d.sanitybyweight, e.sanitybyweight); });	   
}
else
data = data.sort(function(d,e) { return d3.ascending(d.temperature, e.temperature); });	   

circularUpdater();

};	


function NMovum() {

//is no longer a sorting option in the graph.

data = data.sort(function(d,e) { return d3.ascending(d.numberofstudents, e.numberofstudents); });	   

circularUpdater();

};	


function CMovum() {

data = data.sort(function(d,e) { return d3.ascending(d.country, e.country); });	   

circularUpdater();

};	


function Mapum() {	   

rondjes.data(data, function(d) { return d.coordinates; })							  
	   .transition()
	   .duration(timings.rondjesInOut)
	   .attr("transform", function (d) { return "translate(" + projection(d.backoordinates) + ")"; });
	

d3.selectAll("#middenas, #onderas, #bijbakje")	   
		.transition()
		.duration(timings.yAsInOut)
		.style("visibility", "hidden")
		.style("z-index", -10);
		
d3.selectAll(".feature")
			.transition()
			.duration(timings.featureInOut)
			.style("fill-opacity", 1)
			.style("stroke-opacity", 1);

			
};
	

function circularUpdater() {

//alternatief voor sort
//var dataflex = d3.range(data.length);
//	dataflex.sort(function(d,e) { return d3.ascending(data[d].sanity, data[e].sanity); });	   
// .attr("transform", function(d, i) { return "translate(" + dataflex.indexOf(i) + ", 0)"; })

//circularUpdater without any of the above sorters gives the raw data order. Is not a selectable option in the graph.

//this should be d3-ified by using scales!!!
if (globalfirstVar == "ph") {
data.forEach(function(d,i) { return d.coordinates = [i/12.5-70, d.ph*25-164]; });
}
else
if (globalfirstVar == "sanity") {
data.forEach(function(d,i) { return d.coordinates = [i/1.35-72, d.sanity*1.2-40]; });
}
else
if (globalfirstVar == "dropsofbleach") {
data.forEach(function(d,i) { return d.coordinates = [i*1.12-70, d.dropsofbleach*1.9-42]; });
}


rondjes.data(data, function(d) { return d.coordinates; })
	   .transition()
	   .delay()//(function(d,i) { return i })
	   .duration(timings.rondjesInOut)
	   .attr("transform", function (d) { return "translate(" + projection(d.coordinates) + ")"; });


d3.selectAll(".feature")
			.transition()
			.duration(timings.featureInOut)
			.style("fill-opacity", .3)
			.style("stroke-opacity", .4);

d3.selectAll("#middenas, #onderas, #bijbakje")	   
		.transition()
		.delay(timings.yAsInOutDelay)
		.duration(timings.yAsInOut)
		.style("visibility", "visible")
		.style("z-index", 100);
		
		
};	
	

/**
 * Re-orient visualization when moved
 **/
function move() {
    projection.translate(d3.event.translate).scale(d3.event.scale);

    feature.attr("d", path);
 
	d3.selectAll("circle")
      .attr("transform", function (d) { return "translate(" + projection(d.coordinates) + ")"; })

    //Adapt the size of the circles to the scale of the map so they don't get too small
    q = projection.scale() / 3;
	
	
    r.range([1 * (q / width), 6 * (q / width)]);

	
    d3.select("#datapoints").selectAll("circle")
							.attr("r", function (d) { return r(d[globalsecondVar]); })

};



//rippler - makes rings around the circles; nicked from Jerome Cukier's version 14
function ripple(d) {
    svg.append("circle")
       .attr("transform", function () { return ("translate(" + projection(d.coordinates) + ")"); })
       .attr("r", 200)
       .style("stroke", "deepskyblue")
       .style("stroke-opacity", .7)
       .style("stroke-width", 2)
       .style("fill", "none")

       .transition()
       .delay(timings.ripplerDelay1)
       .duration(timings.rippler)
       .attr("r", 100)

       .transition()
       .delay(timings.ripplerDelay2)
       .duration(timings.rippler)
       .attr("r", 50)

       .transition()
       .delay(timings.ripplerDelay3)
       .duration(timings.rippler)
       .attr("r", 25)

       .transition()
       .delay(timings.ripplerDelay4)
       .duration(timings.rippler)
       .attr("r", 12)

//.style("stroke-opacity","1").style("opacity",.2)
       .each("end", function () { d3.select(this).remove(); })
};



function getCountryTempr(coll, name) {

    var watertype = currentWatertype;
					  
    var watersource = currentWatersource;


    var arr = [];

    if (isExists(coll[name])) {
	
        var cdata = coll[name];
        for (var i in cdata) {
            if ((watertype == "" || watertype == cdata[i].waterType) && (watersource == "" || watersource == cdata[i].waterSource)) { arr.push(cdata[i]); }
        }
    }
    return arr;
};


function overpath(d) {

    var cn = d.properties.name;
	
    if (getCountryTempr(lastData, cn).length < 1)
        return;

    var item = d3.select(this);
	
	item.transition()
		.duration(timings.overpathInOut)
		.attr('fill', '#666');
		
	item.style("cursor", "pointer");
   
	tooltipdiv
            .html("<span class=\"statlabel\">" + cn + "</span>")
            .style("background", "#ddd")
            .style("width", "auto")
            .style("height", "auto")
            .style("z-index", 1000)
			
            .transition()
            .duration(timings.tooltipInOut)
            .style("opacity", 1);
};

function moverpath() {

    tooltipdiv
//to bring in New Zealand
                    .style("top", d3.event.pageY > height / 2 ? (d3.event.pageY - 32) + "px" : (d3.event.pageY + 12) + "px")
                    .style("left", d3.event.pageX > width / 2 ? (d3.event.pageX - 60) + "px" : (d3.event.pageX + 12) + "px");
};

function outpath(d) {
    var item = d3.select(this);

    item.style("cursor", "default");

    tooltipdiv
            .transition()
            .duration(timings.tooltipInOut)
            .style("z-index", -10)
            .style("opacity", 1e-6)

	item.transition()
        .duration(timings.tooltipInOut)
		.attr('fill', '#222');
}





function clickPath(d) {

// kill pending visibility change set by function highlightMeasurements()
    if (highlightTimer != null) {
        clearTimeout(highlightTimer);
    }
	
	var cn = d.properties.name;
	
	  rondjes.attr("visibility", function (d) {
                return cn == d.country ? "visible" : "hidden";
            });


// This bit updates the field containing the averages and other stats  
    filteredData = globalData.filter(function (d) {
        return d.country == cn;
    })


    gemfirstVar = d3.round(d3.mean(filteredData, function (d) { return d[globalfirstVar]; }), 2);
    gemsecondVar = d3.round(d3.mean(filteredData, function (d) { return d[globalsecondVar]; }), 2);


//for histogram & stats
    reeks = filteredData.map(function (d) { return d[globalfirstVar]; });

    doHistogram();


	nrOstud = d3.sum(filteredData, function(d) { return d.numberofstudents; });
	
//for reporting correct averages
    if (reeks.length == 0) {
        gemfirstVar = 0;
        gemsecondVar = 0;
    };

    d3.select("#theNumbers")
            .html("<span class=\"statlabel\">number of measurements: </span><span class=\"stat\">" + reeks.length + "</span><br/><br/><span class=\"statlabel\">average " + globalfirstVarlabel + ": </span><span class=\"stat\">" + gemfirstVar + "</span><br/><span class=\"statlabel\">average " + globalsecondVarlabel + ": </span><span class=\"stat\">" + gemsecondVar + "</span>");
			
    d3.select("#theNumbersBis")
            .html("<span class=\"statlabel\">number of students involved: </span><span class=\"stat\">" + nrOstud + "</span>");

};




d3.select("#experiments")
  .on("change", updateDataset);

  
//d3.select("#mover")
//  .on("mouseover", circularUpdater);

  
d3.select("#tomap")
  .on("mouseover", Mapum);
  
d3.select("#sorter")
  .on("mouseover", Sortum);
  
d3.select("#tymover")
  .on("mouseover", TyMovum);
  
d3.select("#scmover")
  .on("mouseover", ScMovum);

d3.select("#tmover")
  .on("mouseover", TMovum);
  
d3.select("#cmover")
  .on("mouseover", CMovum);
  
//d3.select("#nmover")
//  .on("mouseover", NMovum);

</script>